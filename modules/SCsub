#!/usr/bin/env python
from misc.utility.scons_hints import *

import os

import methods

Import("env")

env_modules = env.Clone()

# Allow modules to detect if they are being built as a module.
env_modules.Append(CPPDEFINES=["GODOT_MODULE"])

Export("env_modules")


# Header with MODULE_*_ENABLED define.
def module_enabled_builder(target, source, env):
    with methods.generated_wrapper(target[0]) as file:
        if not source[1].read():
            file.write("// ")
        file.write(f"#define MODULE_{source[0].read()}_ENABLED")


modules = []
for name in env.modules_detected.keys():
    modules.append(
        env.CommandNoCache(
            f"{name}_enabled.gen.h",
            [env.Value(name.upper()), env.Value(name in env.module_list)],
            env.Run(module_enabled_builder),
        )
    )


# Hardcode certain modules to "always" appear, meaning they will have a
# corresponding header file even if the module itself no longer exists. This
# is for the benefit of letting scripts explicitly utilize them without having
# to recompile when an unrelated module is enabled/disabled.
HARDCODED_MODULES = [
    "bmp",
    "csg",
    "freetype",
    "gdscript",
    "gridmap",
    "jpg",
    "jsonrpc",
    "lightmapper_rd",
    "mbedtls",
    "mono",
    "msdfgen",
    "navigation",
    "regex",
    "svg",
    "tga",
    "webp",
    "websocket",
]

for name in HARDCODED_MODULES:
    if name in env.modules_detected:
        continue
    modules.append(
        env.CommandNoCache(
            f"{name}_enabled.gen.h", [env.Value(name.upper()), env.Value(False)], env.Run(module_enabled_builder)
        )
    )


def register_module_types_builder(target, source, env):
    modules = source[0].read()
    mod_enabled = "\n".join([f'#include "{n}_enabled.gen.h"' for n in modules.keys()])
    mod_inc = "\n".join([f'#include "{p}/register_types.h"' for p in modules.values()])
    mod_init = "\n".join(
        [f"#ifdef MODULE_{n.upper()}_ENABLED\n\tinitialize_{n}_module(p_level);\n#endif" for n in modules.keys()]
    )
    mod_uninit = "\n".join(
        [f"#ifdef MODULE_{n.upper()}_ENABLED\n\tuninitialize_{n}_module(p_level);\n#endif" for n in modules.keys()]
    )
    with methods.generated_wrapper(target) as file:
        file.write(
            f"""\
#include "register_module_types.h"

{mod_enabled}

{mod_inc}

void initialize_modules(ModuleInitializationLevel p_level) {{
{mod_init}
}}

void uninitialize_modules(ModuleInitializationLevel p_level) {{
{mod_uninit}
}}
"""
        )


register_module_types = env.CommandNoCache(
    "register_module_types.gen.cpp", [env.Value(env.modules_detected)] + modules, env.Run(register_module_types_builder)
)


test_headers = []
# libmodule_<name>.a for each active module.
for name, path in env.module_list.items():
    env.modules_sources = []

    # Name for built-in modules, (absolute) path for custom ones.
    base_path = path if os.path.isabs(path) else name
    SConscript(base_path + "/SCsub")

    lib = env_modules.add_library("module_%s" % name, env.modules_sources)
    env.Prepend(LIBS=[lib])

    if env["tests"]:
        # Lookup potential headers in `tests` subfolder.
        import glob

        module_tests = sorted(glob.glob(os.path.join(base_path, "tests", "*.h")))
        if module_tests != []:
            test_headers += module_tests


# Generate header to be included in `tests/test_main.cpp` to run module-specific tests.
if env["tests"]:

    def modules_tests_builder(target, source, env):
        with methods.generated_wrapper(target) as file:
            for header in source:
                file.write('#include "{}"\n'.format(os.path.normpath(header.path).replace("\\", "/")))

    env.CommandNoCache("modules_tests.gen.h", test_headers, env.Run(modules_tests_builder))

# libmodules.a with only register_module_types.
# Must be last so that all libmodule_<name>.a libraries are on the right side
# in the linker command.
env.modules_sources = []
env_modules.add_source_files(env.modules_sources, register_module_types)
lib = env_modules.add_library("modules", env.modules_sources)
env.Prepend(LIBS=[lib])
